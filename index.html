<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orb Prototype</title>
  <style>
    @font-face {
      font-family: 'Neue Haas Grotesk';
      src: url('NHaasGroteskTXPro-65Md.ttf') format('truetype');
      font-weight: 500;
      font-style: normal;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      min-height: 100vh;
      font-family: 'Neue Haas Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      cursor: grab;
    }

    body:active {
      cursor: grabbing;
    }

    .scene {
      width: 600px;
      height: 600px;
      perspective: 1000px;
      position: relative;
    }

    .sphere {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
    }

    .text-line {
      position: absolute;
      top: 50%;
      left: 50%;
      color: #fff;
      font-weight: 500;
      white-space: nowrap;
      transform-style: preserve-3d;
      /* Allow back text to show through */
      backface-visibility: visible;
    }

    /* Glass orb overlay */
    .orb-glass {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 480px;
      height: 480px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow:
        inset 0 0 120px rgba(0, 0, 0, 0.4);
      pointer-events: none;
      z-index: 1000;
    }

    .orb-glass::before {
      content: '';
      position: absolute;
      top: 8%;
      left: 15%;
      width: 30%;
      height: 20%;
      background: radial-gradient(
        ellipse,
        rgba(255, 255, 255, 0.1) 0%,
        transparent 70%
      );
      border-radius: 50%;
      filter: blur(10px);
    }

    /* Header */
    .header {
      position: fixed;
      top: 40px;
      left: 40px;
      color: #fff;
      z-index: 200;
    }

    .header h1 {
      font-size: 36px;
      font-weight: 500;
      line-height: 0.92;
      letter-spacing: -1.08px;
    }

    .menu {
      position: fixed;
      top: 40px;
      right: 40px;
      color: #fff;
      font-size: 36px;
      font-weight: 500;
      z-index: 200;
    }

    .footer {
      position: fixed;
      bottom: 40px;
      left: 40px;
      color: #fff;
      max-width: 400px;
      z-index: 200;
    }

    .footer p {
      font-size: 18px;
      line-height: 1.4;
      opacity: 0.8;
    }

    .hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Everywhere<br>Edition</h1>
  </div>

  <div class="menu">Menu</div>

  <div class="scene" id="scene">
    <div class="sphere" id="sphere">
      <!-- Text lines will be added by JavaScript -->
    </div>
    <div class="orb-glass"></div>
  </div>

  <div class="footer">
    <p>Manage how your brand appears to the millions of users shopping in AI chats. Your products are discoverable right in ChatGPT, Copilot, and Perplexity.</p>
  </div>

  <div class="hint">Drag to spin</div>

  <script>
    const sphere = document.getElementById('sphere');
    const scene = document.getElementById('scene');

    // Content lines
    const contentLines = [
      "Payment method customization",
      "Shop Cash rewards program",
      "Extended warranty options",
      "Flexible inventory transfers",
      "Updated metrics and widgets",
      "Monitor your store from your wrist",
      "Create fully functional admin applications",
      "through simple conversations with Sidekick",
      "starting with custom discount functions.",
      "No coding knowledge required.",
      "Earn 1% Shop Cash exclusively on purchases",
      "made in the Shop app with extended expiry",
      "updates, making rewards more accessible and",
      "valuable for your customers.",
      "Custom Shop app URLs",
    ];

    const RADIUS = 240;
    const TOTAL_RINGS = 15;

    // Create text positioned on sphere surface
    function createTextLines() {
      for (let i = 0; i < TOTAL_RINGS; i++) {
        // Distribute lines from top to bottom of sphere
        // phi goes from ~20° to ~160° (avoiding poles)
        const phi = (Math.PI * 0.12) + (Math.PI * 0.76) * (i / (TOTAL_RINGS - 1));

        const line = document.createElement('div');
        line.className = 'text-line';
        line.textContent = contentLines[i % contentLines.length];
        line.dataset.phi = phi;
        line.dataset.index = i;

        sphere.appendChild(line);
      }
    }

    createTextLines();

    let rotationX = -10;
    let rotationY = 0;
    let velocityX = 0;
    let velocityY = 0.3;
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    function updateSphere() {
      const lines = document.querySelectorAll('.text-line');
      const radX = rotationX * Math.PI / 180;
      const radY = rotationY * Math.PI / 180;

      lines.forEach(line => {
        const phi = parseFloat(line.dataset.phi);

        // Position on sphere - theta is 0 (front-facing)
        // We'll rotate the whole coordinate system instead
        const baseY = RADIUS * Math.cos(phi);
        const ringRadius = RADIUS * Math.sin(phi);
        const baseX = 0;
        const baseZ = ringRadius;

        // Apply Y rotation (horizontal spin)
        let x = baseX * Math.cos(radY) - baseZ * Math.sin(radY);
        let z = baseX * Math.sin(radY) + baseZ * Math.cos(radY);
        let y = baseY;

        // Apply X rotation (vertical tilt)
        const newY = y * Math.cos(radX) - z * Math.sin(radX);
        const newZ = y * Math.sin(radX) + z * Math.cos(radX);
        y = newY;
        z = newZ;

        // Calculate visual properties based on Z depth
        const normalizedZ = (z + RADIUS) / (RADIUS * 2); // 0 = back, 1 = front

        // Front text (z > 0): full opacity, larger
        // Back text (z < 0): dimmer, smaller, appears reversed naturally via 3D
        const isFront = z > 0;

        let opacity, scale, fontSize;

        if (isFront) {
          // Front of sphere
          opacity = 0.4 + normalizedZ * 0.6;
          scale = 0.6 + normalizedZ * 0.5;
          fontSize = 14 + normalizedZ * 10;
        } else {
          // Back of sphere - visible but dimmer
          opacity = 0.1 + normalizedZ * 0.25;
          scale = 0.4 + normalizedZ * 0.3;
          fontSize = 12 + normalizedZ * 6;
        }

        // Calculate the rotation needed for the text to face outward on the sphere
        // then the natural 3D perspective will make back text appear reversed
        const angleY = Math.atan2(x, z) * (180 / Math.PI);

        line.style.transform = `
          translate(-50%, -50%)
          translate3d(${x}px, ${y}px, ${z}px)
          rotateY(${angleY}deg)
        `;
        line.style.opacity = opacity;
        line.style.fontSize = `${fontSize}px`;
        line.style.zIndex = Math.round(z + RADIUS);
      });
    }

    function animate() {
      if (!isDragging) {
        rotationY += velocityY;
        rotationX += velocityX;

        velocityX *= 0.96;
        velocityY *= 0.995;

        if (Math.abs(velocityY) < 0.2) velocityY = 0.2;
      }

      rotationX = Math.max(-40, Math.min(40, rotationX));

      updateSphere();
      requestAnimationFrame(animate);
    }

    // Mouse controls
    scene.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      velocityX = 0;
      velocityY = 0;
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const deltaX = e.clientX - lastMouseX;
      const deltaY = e.clientY - lastMouseY;

      rotationY += deltaX * 0.4;
      rotationX += deltaY * 0.3;

      velocityY = deltaX * 0.15;
      velocityX = deltaY * 0.1;

      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    // Touch support
    scene.addEventListener('touchstart', (e) => {
      isDragging = true;
      lastMouseX = e.touches[0].clientX;
      lastMouseY = e.touches[0].clientY;
      velocityX = 0;
      velocityY = 0;
    });

    document.addEventListener('touchmove', (e) => {
      if (!isDragging) return;

      const deltaX = e.touches[0].clientX - lastMouseX;
      const deltaY = e.touches[0].clientY - lastMouseY;

      rotationY += deltaX * 0.4;
      rotationX += deltaY * 0.3;

      velocityY = deltaX * 0.15;
      velocityX = deltaY * 0.1;

      lastMouseX = e.touches[0].clientX;
      lastMouseY = e.touches[0].clientY;
    });

    document.addEventListener('touchend', () => {
      isDragging = false;
    });

    animate();
  </script>
</body>
</html>
