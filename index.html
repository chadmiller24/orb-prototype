<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orb Prototype</title>
  <style>
    @font-face {
      font-family: 'Neue Haas Grotesk';
      src: url('NHaasGroteskTXPro-65Md.ttf') format('truetype');
      font-weight: 500;
      font-style: normal;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      min-height: 100vh;
      font-family: 'Neue Haas Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      cursor: grab;
    }

    body:active {
      cursor: grabbing;
    }

    .scene {
      width: 700px;
      height: 700px;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .orb-container {
      width: 500px;
      height: 500px;
      position: relative;
      border-radius: 50%;
      overflow: hidden;
    }

    /* The glass orb edge */
    .orb-edge {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      height: 500px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.12);
      pointer-events: none;
      z-index: 100;
      box-shadow:
        inset 0 0 100px rgba(0, 0, 0, 0.6);
    }

    /* Text container inside orb */
    .text-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    /* Back text layer - mirrored */
    .text-container.back {
      transform: translate(-50%, -50%) scaleX(-1);
    }

    .text-line {
      position: absolute;
      color: #fff;
      font-weight: 500;
      white-space: nowrap;
      line-height: 1.3;
      text-align: center;
      left: 50%;
    }

    /* Header */
    .header {
      position: fixed;
      top: 40px;
      left: 40px;
      color: #fff;
      z-index: 200;
    }

    .header h1 {
      font-size: 36px;
      font-weight: 500;
      line-height: 0.92;
      letter-spacing: -1.08px;
    }

    .menu {
      position: fixed;
      top: 40px;
      right: 40px;
      color: #fff;
      font-size: 36px;
      font-weight: 500;
      z-index: 200;
    }

    .footer {
      position: fixed;
      bottom: 40px;
      left: 40px;
      color: #fff;
      max-width: 400px;
      z-index: 200;
    }

    .footer p {
      font-size: 18px;
      line-height: 1.4;
      opacity: 0.8;
    }

    .hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Everywhere<br>Edition</h1>
  </div>

  <div class="menu">Menu</div>

  <div class="scene" id="scene">
    <div class="orb-container" id="orbContainer">
      <div class="text-container back" id="backTextContainer">
        <!-- Back text lines (mirrored) -->
      </div>
      <div class="text-container front" id="frontTextContainer">
        <!-- Front text lines -->
      </div>
    </div>
    <div class="orb-edge"></div>
  </div>

  <div class="footer">
    <p>Manage how your brand appears to the millions of users shopping in AI chats. Your products are discoverable right in ChatGPT, Copilot, and Perplexity.</p>
  </div>

  <div class="hint">Drag to spin</div>

  <script>
    const frontTextContainer = document.getElementById('frontTextContainer');
    const backTextContainer = document.getElementById('backTextContainer');
    const scene = document.getElementById('scene');

    // Content lines
    const contentLines = [
      "Payment method customization",
      "Shop Cash rewards program",
      "Extended warranty options",
      "Flexible inventory transfers",
      "Updated metrics and widgets",
      "Monitor your store from your wrist",
      "Create fully functional admin applications",
      "through simple conversations with Sidekick",
      "starting with custom discount functions.",
      "No coding knowledge required.",
      "Earn 1% Shop Cash exclusively on purchases",
      "made in the Shop app with extended expiry",
      "updates, making rewards more accessible and",
      "valuable for your customers.",
      "Custom Shop app URLs",
      "Earn 1% Shop Cash exclusively on purchases",
      "made in the Shop app with extended expiry",
      "updates, making rewards more accessible",
      "and valuable for your customers.",
    ];

    const ORB_RADIUS = 250;
    const LINE_HEIGHT = 30;
    let scrollY = 0;
    let velocityY = 0.4;
    let isDragging = false;
    let lastMouseY = 0;

    // Create text lines for both front and back
    function createTextLines() {
      const totalLines = contentLines.length * 2;

      // Front layer
      for (let i = 0; i < totalLines; i++) {
        const line = document.createElement('div');
        line.className = 'text-line';
        line.textContent = contentLines[i % contentLines.length];
        line.dataset.index = i;
        frontTextContainer.appendChild(line);
      }

      // Back layer (will be mirrored via CSS)
      for (let i = 0; i < totalLines; i++) {
        const line = document.createElement('div');
        line.className = 'text-line';
        line.textContent = contentLines[i % contentLines.length];
        line.dataset.index = i;
        backTextContainer.appendChild(line);
      }
    }

    createTextLines();

    function updateTextPositions() {
      const frontLines = frontTextContainer.querySelectorAll('.text-line');
      const backLines = backTextContainer.querySelectorAll('.text-line');
      const totalHeight = contentLines.length * LINE_HEIGHT;

      // Update front text
      frontLines.forEach((line, index) => {
        let y = (index * LINE_HEIGHT) - scrollY - totalHeight / 2;

        // Wrap around
        while (y < -totalHeight) y += totalHeight;
        while (y > totalHeight) y -= totalHeight;

        const normalizedDist = y / ORB_RADIUS;

        if (Math.abs(normalizedDist) > 0.95) {
          line.style.opacity = 0;
          return;
        }

        // Sphere surface calculation
        const sphereZ = Math.sqrt(Math.max(0, 1 - normalizedDist * normalizedDist));

        // Fisheye effect - center text is larger
        const scale = 0.4 + sphereZ * 0.9;
        const fontSize = 14 + sphereZ * 10;

        // Opacity - front text is bright in center, fades at edges
        const opacity = Math.pow(sphereZ, 0.6);

        line.style.transform = `translate(-50%, -50%) translateY(${y}px) scale(${scale})`;
        line.style.opacity = opacity;
        line.style.fontSize = `${fontSize}px`;
        line.style.zIndex = Math.round(sphereZ * 100);
      });

      // Update back text (offset and dimmer)
      backLines.forEach((line, index) => {
        // Offset the back text so it doesn't perfectly overlap
        let y = (index * LINE_HEIGHT) - scrollY - totalHeight / 2 + LINE_HEIGHT * 0.5;

        while (y < -totalHeight) y += totalHeight;
        while (y > totalHeight) y -= totalHeight;

        const normalizedDist = y / ORB_RADIUS;

        if (Math.abs(normalizedDist) > 0.95) {
          line.style.opacity = 0;
          return;
        }

        const sphereZ = Math.sqrt(Math.max(0, 1 - normalizedDist * normalizedDist));

        // Back text is smaller and dimmer
        const scale = 0.35 + sphereZ * 0.5;
        const fontSize = 12 + sphereZ * 6;

        // Back text fades more aggressively
        const opacity = Math.pow(sphereZ, 1.5) * 0.35;

        line.style.transform = `translate(-50%, -50%) translateY(${y}px) scale(${scale})`;
        line.style.opacity = opacity;
        line.style.fontSize = `${fontSize}px`;
        line.style.zIndex = Math.round(sphereZ * 10);
      });
    }

    function animate() {
      if (!isDragging) {
        scrollY += velocityY;
        velocityY *= 0.998;
        if (Math.abs(velocityY) < 0.25) velocityY = 0.25;
      }

      const totalHeight = contentLines.length * LINE_HEIGHT;
      if (scrollY > totalHeight) scrollY -= totalHeight;
      if (scrollY < 0) scrollY += totalHeight;

      updateTextPositions();
      requestAnimationFrame(animate);
    }

    // Mouse controls
    scene.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastMouseY = e.clientY;
      velocityY = 0;
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const deltaY = e.clientY - lastMouseY;
      scrollY -= deltaY * 0.8;
      velocityY = -deltaY * 0.3;
      lastMouseY = e.clientY;
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    // Touch support
    scene.addEventListener('touchstart', (e) => {
      isDragging = true;
      lastMouseY = e.touches[0].clientY;
      velocityY = 0;
    });

    document.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      const deltaY = e.touches[0].clientY - lastMouseY;
      scrollY -= deltaY * 0.8;
      velocityY = -deltaY * 0.3;
      lastMouseY = e.touches[0].clientY;
    });

    document.addEventListener('touchend', () => {
      isDragging = false;
    });

    animate();
  </script>
</body>
</html>
