<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orb Prototype</title>
  <style>
    @font-face {
      font-family: 'Neue Haas Grotesk';
      src: url('NHaasGroteskTXPro-65Md.ttf') format('truetype');
      font-weight: 500;
      font-style: normal;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      min-height: 100vh;
      font-family: 'Neue Haas Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
      overflow: hidden;
      cursor: grab;
    }

    body:active {
      cursor: grabbing;
    }

    #canvas {
      width: 100%;
      height: 100vh;
      display: block;
    }

    /* Header */
    .header {
      position: fixed;
      top: 40px;
      left: 40px;
      color: #fff;
      z-index: 200;
    }

    .header h1 {
      font-size: 36px;
      font-weight: 500;
      line-height: 0.92;
      letter-spacing: -1.08px;
    }

    .menu {
      position: fixed;
      top: 40px;
      right: 40px;
      color: #fff;
      font-size: 36px;
      font-weight: 500;
      z-index: 200;
    }

    .footer {
      position: fixed;
      bottom: 40px;
      left: 40px;
      color: #fff;
      max-width: 400px;
      z-index: 200;
    }

    .footer p {
      font-size: 18px;
      line-height: 1.4;
      opacity: 0.8;
    }

    .hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Everywhere<br>Edition</h1>
  </div>

  <div class="menu">Menu</div>

  <canvas id="canvas"></canvas>

  <div class="footer">
    <p>Manage how your brand appears to the millions of users shopping in AI chats. Your products are discoverable right in ChatGPT, Copilot, and Perplexity.</p>
  </div>

  <div class="hint">Drag to spin</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    const canvas = document.getElementById('canvas');

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 4;

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 1);

    // Load texture from Figma
    const textureLoader = new THREE.TextureLoader();
    const orbTexture = textureLoader.load('orb-texture.png');

    // Create sphere with texture
    const geometry = new THREE.SphereGeometry(1.5, 64, 64);
    const material = new THREE.MeshBasicMaterial({
      map: orbTexture,
      transparent: true,
      side: THREE.DoubleSide
    });
    const sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);

    // Glass overlay sphere (slightly larger)
    const glassGeometry = new THREE.SphereGeometry(1.52, 64, 64);
    const glassMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.03,
      side: THREE.FrontSide
    });
    const glassSphere = new THREE.Mesh(glassGeometry, glassMaterial);
    scene.add(glassSphere);

    // Rotation state
    let targetRotationX = 0;
    let targetRotationY = 0;
    let rotationX = 0;
    let rotationY = 0;
    let velocityX = 0;
    let velocityY = 0.003;
    let isDragging = false;
    let previousMouseX = 0;
    let previousMouseY = 0;

    // Mouse controls
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMouseX = e.clientX;
      previousMouseY = e.clientY;
      velocityX = 0;
      velocityY = 0;
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const deltaX = e.clientX - previousMouseX;
      const deltaY = e.clientY - previousMouseY;

      targetRotationY += deltaX * 0.005;
      targetRotationX += deltaY * 0.005;

      velocityY = deltaX * 0.002;
      velocityX = deltaY * 0.002;

      previousMouseX = e.clientX;
      previousMouseY = e.clientY;
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    // Touch support
    canvas.addEventListener('touchstart', (e) => {
      isDragging = true;
      previousMouseX = e.touches[0].clientX;
      previousMouseY = e.touches[0].clientY;
      velocityX = 0;
      velocityY = 0;
    });

    document.addEventListener('touchmove', (e) => {
      if (!isDragging) return;

      const deltaX = e.touches[0].clientX - previousMouseX;
      const deltaY = e.touches[0].clientY - previousMouseY;

      targetRotationY += deltaX * 0.005;
      targetRotationX += deltaY * 0.005;

      velocityY = deltaX * 0.002;
      velocityX = deltaY * 0.002;

      previousMouseX = e.touches[0].clientX;
      previousMouseY = e.touches[0].clientY;
    });

    document.addEventListener('touchend', () => {
      isDragging = false;
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      if (!isDragging) {
        // Apply momentum
        targetRotationY += velocityY;
        targetRotationX += velocityX;

        // Dampen velocity
        velocityX *= 0.95;
        velocityY *= 0.98;

        // Minimum auto-rotation
        if (Math.abs(velocityY) < 0.002) velocityY = 0.002;
      }

      // Clamp X rotation
      targetRotationX = Math.max(-0.8, Math.min(0.8, targetRotationX));

      // Smooth rotation
      rotationX += (targetRotationX - rotationX) * 0.1;
      rotationY += (targetRotationY - rotationY) * 0.1;

      sphere.rotation.x = rotationX;
      sphere.rotation.y = rotationY;
      glassSphere.rotation.x = rotationX;
      glassSphere.rotation.y = rotationY;

      renderer.render(scene, camera);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
