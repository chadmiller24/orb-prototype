<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orb Prototype</title>
  <style>
    @font-face {
      font-family: 'Neue Haas Grotesk';
      src: url('NHaasGroteskTXPro-65Md.ttf') format('truetype');
      font-weight: 500;
      font-style: normal;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      min-height: 100vh;
      font-family: 'Neue Haas Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      cursor: grab;
    }

    body:active {
      cursor: grabbing;
    }

    .scene {
      width: 600px;
      height: 600px;
      perspective: 1200px;
      position: relative;
    }

    .orb-container {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
    }

    /* The glass orb effect - subtle, see-through */
    .orb {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 420px;
      height: 420px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: radial-gradient(
        ellipse at 30% 30%,
        rgba(255, 255, 255, 0.08) 0%,
        rgba(255, 255, 255, 0.02) 40%,
        transparent 70%
      );
      box-shadow:
        inset 0 0 80px rgba(255, 255, 255, 0.03),
        0 0 40px rgba(255, 255, 255, 0.02);
      pointer-events: none;
      z-index: 1000;
    }

    /* Highlight reflection */
    .orb::before {
      content: '';
      position: absolute;
      top: 8%;
      left: 12%;
      width: 35%;
      height: 25%;
      background: radial-gradient(
        ellipse,
        rgba(255, 255, 255, 0.15) 0%,
        transparent 70%
      );
      border-radius: 50%;
      filter: blur(8px);
    }

    /* Subtle edge */
    .orb::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    /* Text ring container */
    .text-ring {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      transform-style: preserve-3d;
    }

    /* Individual character */
    .char {
      position: absolute;
      color: #fff;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.5px;
      transform-style: preserve-3d;
    }

    /* Header */
    .header {
      position: fixed;
      top: 40px;
      left: 40px;
      color: #fff;
      z-index: 200;
    }

    .header h1 {
      font-size: 36px;
      font-weight: 500;
      line-height: 0.92;
      letter-spacing: -1.08px;
    }

    .menu {
      position: fixed;
      top: 40px;
      right: 40px;
      color: #fff;
      font-size: 36px;
      font-weight: 500;
      z-index: 200;
    }

    .footer {
      position: fixed;
      bottom: 40px;
      left: 40px;
      color: #fff;
      max-width: 400px;
      z-index: 200;
    }

    .footer p {
      font-size: 18px;
      line-height: 1.4;
      opacity: 0.8;
    }

    .hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Everywhere<br>Edition</h1>
  </div>

  <div class="menu">Menu</div>

  <div class="scene" id="scene">
    <div class="orb-container" id="orbContainer">
      <!-- Text rings will be added by JavaScript -->
    </div>
    <div class="orb"></div>
  </div>

  <div class="footer">
    <p>Manage how your brand appears to the millions of users shopping in AI chats. Your products are discoverable right in ChatGPT, Copilot, and Perplexity.</p>
  </div>

  <div class="hint">Drag to spin</div>

  <script>
    const orbContainer = document.getElementById('orbContainer');
    const scene = document.getElementById('scene');

    // Content items - shorter phrases that wrap around rings
    const contentItems = [
      "Shop Cash rewards • Extended warranty • Flexible transfers • Shop Cash rewards • Extended warranty •",
      "Payment customization • Custom URLs • Updated metrics • Payment customization • Custom URLs •",
      "Earn 1% Shop Cash • Made in Shop app • Extended expiry • Earn 1% Shop Cash • Made in Shop app •",
      "Admin applications • Sidekick conversations • Custom functions • Admin applications • Sidekick •",
      "Discount functions • No coding required • Accessible rewards • Discount functions • No coding •",
      "Rewards accessible • Valuable customers • Monitor store • Rewards accessible • Valuable customers •",
      "From your wrist • Analytics dashboard • Real-time data • From your wrist • Analytics dashboard •"
    ];

    const RADIUS = 200;
    const CHAR_WIDTH = 9;

    // Create text wrapped around rings
    function createTextRings() {
      contentItems.forEach((text, ringIndex) => {
        // Vertical position (latitude) - distribute rings from top to bottom
        const phi = (Math.PI / (contentItems.length + 1)) * (ringIndex + 1);

        // Calculate the radius of this ring (smaller near poles)
        const ringRadius = RADIUS * Math.sin(phi);
        const y = RADIUS * Math.cos(phi);

        // Angle per character
        const charAngle = CHAR_WIDTH / ringRadius;

        // Create a ring container
        const ring = document.createElement('div');
        ring.className = 'text-ring';
        ring.dataset.phi = phi;
        ring.dataset.y = y;
        ring.dataset.ringRadius = ringRadius;

        // Place each character around the ring
        const chars = text.split('');
        chars.forEach((char, charIndex) => {
          const theta = charIndex * charAngle;

          const charEl = document.createElement('span');
          charEl.className = 'char';
          charEl.textContent = char;
          charEl.dataset.theta = theta;
          charEl.dataset.charIndex = charIndex;

          ring.appendChild(charEl);
        });

        orbContainer.appendChild(ring);
      });
    }

    createTextRings();

    // Rotation state
    let rotationX = -15;
    let rotationY = 0;
    let velocityX = 0;
    let velocityY = 0.25;
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    function updatePositions() {
      const radX = rotationX * Math.PI / 180;
      const radY = rotationY * Math.PI / 180;

      const rings = document.querySelectorAll('.text-ring');

      rings.forEach(ring => {
        const phi = parseFloat(ring.dataset.phi);
        const ringRadius = parseFloat(ring.dataset.ringRadius);
        const baseY = parseFloat(ring.dataset.y);

        const chars = ring.querySelectorAll('.char');

        chars.forEach(charEl => {
          const theta = parseFloat(charEl.dataset.theta) + radY;

          // Position on the ring
          const x = ringRadius * Math.cos(theta);
          const z = ringRadius * Math.sin(theta);
          let y = baseY;

          // Apply X rotation (tilt)
          const rotatedY = y * Math.cos(radX) - z * Math.sin(radX);
          const rotatedZ = y * Math.sin(radX) + z * Math.cos(radX);

          // Calculate opacity based on depth
          // Front text is brighter, back text is dimmer but still visible
          const normalizedDepth = (rotatedZ + RADIUS) / (RADIUS * 2);

          // Back text (z < 0) should be visible but dimmer
          // Front text (z > 0) should be bright
          let opacity;
          if (rotatedZ < 0) {
            // Back of sphere - visible but faded
            opacity = 0.15 + normalizedDepth * 0.2;
          } else {
            // Front of sphere - full visibility
            opacity = 0.4 + normalizedDepth * 0.6;
          }

          // Scale based on depth for perspective
          const scale = 0.7 + normalizedDepth * 0.4;

          // Rotation to face outward (tangent to sphere)
          // Back text will naturally appear mirrored because we see it from behind
          const faceAngle = theta * (180 / Math.PI);

          charEl.style.transform = `
            translate3d(${x}px, ${rotatedY}px, ${rotatedZ}px)
            rotateY(${faceAngle + 90}deg)
            scale(${scale})
          `;
          charEl.style.opacity = opacity;

          // Z-index: back text should be behind front text
          charEl.style.zIndex = Math.round(rotatedZ + RADIUS);
        });
      });
    }

    function animate() {
      if (!isDragging) {
        rotationY += velocityY;
        rotationX += velocityX;

        velocityX *= 0.98;
        velocityY *= 0.998;

        if (Math.abs(velocityY) < 0.15) velocityY = 0.15;
      }

      rotationX = Math.max(-60, Math.min(60, rotationX));

      updatePositions();
      requestAnimationFrame(animate);
    }

    // Mouse/touch controls
    scene.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      velocityX = 0;
      velocityY = 0;
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const deltaX = e.clientX - lastMouseX;
      const deltaY = e.clientY - lastMouseY;

      rotationY += deltaX * 0.5;
      rotationX += deltaY * 0.3;

      velocityY = deltaX * 0.2;
      velocityX = deltaY * 0.1;

      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    // Touch support
    scene.addEventListener('touchstart', (e) => {
      isDragging = true;
      lastMouseX = e.touches[0].clientX;
      lastMouseY = e.touches[0].clientY;
      velocityX = 0;
      velocityY = 0;
    });

    document.addEventListener('touchmove', (e) => {
      if (!isDragging) return;

      const deltaX = e.touches[0].clientX - lastMouseX;
      const deltaY = e.touches[0].clientY - lastMouseY;

      rotationY += deltaX * 0.5;
      rotationX += deltaY * 0.3;

      velocityY = deltaX * 0.2;
      velocityX = deltaY * 0.1;

      lastMouseX = e.touches[0].clientX;
      lastMouseY = e.touches[0].clientY;
    });

    document.addEventListener('touchend', () => {
      isDragging = false;
    });

    animate();
  </script>
</body>
</html>
