<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orb Prototype</title>
  <style>
    @font-face {
      font-family: 'Neue Haas Grotesk';
      src: url('NHaasGroteskTXPro-65Md.ttf') format('truetype');
      font-weight: 500;
      font-style: normal;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      min-height: 100vh;
      font-family: 'Neue Haas Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      cursor: grab;
    }

    body:active {
      cursor: grabbing;
    }

    .scene {
      width: 600px;
      height: 600px;
      perspective: 1000px;
      position: relative;
    }

    .orb-container {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
    }

    /* The glass orb effect */
    .orb {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 400px;
      height: 400px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: radial-gradient(
        ellipse at 30% 30%,
        rgba(255, 255, 255, 0.12) 0%,
        rgba(255, 255, 255, 0.03) 30%,
        rgba(0, 0, 0, 0.05) 60%,
        rgba(0, 0, 0, 0.2) 100%
      );
      box-shadow:
        inset -20px -20px 40px rgba(0, 0, 0, 0.4),
        inset 20px 20px 40px rgba(255, 255, 255, 0.08),
        0 0 60px rgba(255, 255, 255, 0.05);
      pointer-events: none;
      z-index: 100;
    }

    .orb::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 15%;
      width: 30%;
      height: 20%;
      background: radial-gradient(
        ellipse,
        rgba(255, 255, 255, 0.25) 0%,
        transparent 70%
      );
      border-radius: 50%;
      filter: blur(10px);
    }

    /* Text ring container */
    .text-ring {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      transform-style: preserve-3d;
    }

    /* Individual character */
    .char {
      position: absolute;
      color: #fff;
      font-size: 16px;
      font-weight: 500;
      transform-style: preserve-3d;
      backface-visibility: hidden;
    }

    /* Header */
    .header {
      position: fixed;
      top: 40px;
      left: 40px;
      color: #fff;
      z-index: 200;
    }

    .header h1 {
      font-size: 36px;
      font-weight: 500;
      line-height: 0.92;
      letter-spacing: -1.08px;
    }

    .menu {
      position: fixed;
      top: 40px;
      right: 40px;
      color: #fff;
      font-size: 36px;
      font-weight: 500;
      z-index: 200;
    }

    .footer {
      position: fixed;
      bottom: 40px;
      left: 40px;
      color: #fff;
      max-width: 400px;
      z-index: 200;
    }

    .footer p {
      font-size: 18px;
      line-height: 1.4;
      opacity: 0.8;
    }

    .hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Everywhere<br>Edition</h1>
  </div>

  <div class="menu">Menu</div>

  <div class="scene" id="scene">
    <div class="orb-container" id="orbContainer">
      <!-- Text rings will be added by JavaScript -->
    </div>
    <div class="orb"></div>
  </div>

  <div class="footer">
    <p>Manage how your brand appears to the millions of users shopping in AI chats. Your products are discoverable right in ChatGPT, Copilot, and Perplexity.</p>
  </div>

  <div class="hint">Drag to spin</div>

  <script>
    const orbContainer = document.getElementById('orbContainer');
    const scene = document.getElementById('scene');

    // Content items - each will wrap around a ring of the sphere
    const contentItems = [
      "Shop Cash rewards program • Extended warranty options • Flexible inventory transfers •",
      "Payment method customization • Custom Shop app URLs • Updated metrics and widgets •",
      "Earn 1% Shop Cash exclusively on purchases • Made in the Shop app with extended expiry •",
      "Create fully functional admin applications • Through simple conversations with Sidekick •",
      "Starting with custom discount functions • No coding knowledge required •",
      "Updates making rewards more accessible • And valuable for your customers •",
      "Monitor your store from your wrist • Real-time analytics dashboard •"
    ];

    const RADIUS = 200;
    const CHAR_WIDTH = 10; // Approximate character width for spacing

    // Create text wrapped around rings
    function createTextRings() {
      contentItems.forEach((text, ringIndex) => {
        // Vertical position (latitude) - distribute rings from top to bottom
        const phi = (Math.PI / (contentItems.length + 1)) * (ringIndex + 1);

        // Calculate the radius of this ring (smaller near poles)
        const ringRadius = RADIUS * Math.sin(phi);
        const y = RADIUS * Math.cos(phi);

        // Calculate circumference and how many characters fit
        const circumference = 2 * Math.PI * ringRadius;
        const charAngle = CHAR_WIDTH / ringRadius; // Angle per character

        // Create a ring container
        const ring = document.createElement('div');
        ring.className = 'text-ring';
        ring.dataset.phi = phi;
        ring.dataset.y = y;
        ring.dataset.ringRadius = ringRadius;

        // Place each character around the ring
        const chars = text.split('');
        chars.forEach((char, charIndex) => {
          const theta = charIndex * charAngle;

          const charEl = document.createElement('span');
          charEl.className = 'char';
          charEl.textContent = char;
          charEl.dataset.theta = theta;
          charEl.dataset.charIndex = charIndex;

          ring.appendChild(charEl);
        });

        orbContainer.appendChild(ring);
      });
    }

    createTextRings();

    // Rotation state
    let rotationX = -20;
    let rotationY = 0;
    let velocityX = 0;
    let velocityY = 0.3; // Auto-rotate
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    function updatePositions() {
      const radX = rotationX * Math.PI / 180;
      const radY = rotationY * Math.PI / 180;

      const rings = document.querySelectorAll('.text-ring');

      rings.forEach(ring => {
        const phi = parseFloat(ring.dataset.phi);
        const ringRadius = parseFloat(ring.dataset.ringRadius);
        const baseY = parseFloat(ring.dataset.y);

        const chars = ring.querySelectorAll('.char');

        chars.forEach(charEl => {
          const theta = parseFloat(charEl.dataset.theta) + radY;

          // Position on the ring
          const x = ringRadius * Math.cos(theta);
          const z = ringRadius * Math.sin(theta);
          let y = baseY;

          // Apply X rotation (tilt)
          const rotatedY = y * Math.cos(radX) - z * Math.sin(radX);
          const rotatedZ = y * Math.sin(radX) + z * Math.cos(radX);

          // Calculate opacity based on depth
          const depth = rotatedZ;
          const normalizedDepth = (depth + RADIUS) / (RADIUS * 2);
          const opacity = Math.max(0.05, Math.min(1, normalizedDepth * 1.2));

          // Scale based on depth for perspective
          const scale = 0.6 + normalizedDepth * 0.5;

          // Rotation to face outward (tangent to sphere)
          const faceAngle = theta * (180 / Math.PI);

          charEl.style.transform = `
            translate3d(${x}px, ${rotatedY}px, ${rotatedZ}px)
            rotateY(${faceAngle + 90}deg)
            scale(${scale})
          `;
          charEl.style.opacity = opacity;
          charEl.style.zIndex = Math.round(rotatedZ + RADIUS);
        });
      });
    }

    function animate() {
      if (!isDragging) {
        // Apply auto-rotation and momentum
        rotationY += velocityY;
        rotationX += velocityX;

        // Dampen velocity
        velocityX *= 0.98;
        velocityY *= 0.998;

        // Minimum auto-rotation
        if (Math.abs(velocityY) < 0.15) velocityY = 0.15;
      }

      // Clamp X rotation
      rotationX = Math.max(-60, Math.min(60, rotationX));

      updatePositions();
      requestAnimationFrame(animate);
    }

    // Mouse/touch controls
    scene.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      velocityX = 0;
      velocityY = 0;
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const deltaX = e.clientX - lastMouseX;
      const deltaY = e.clientY - lastMouseY;

      rotationY += deltaX * 0.5;
      rotationX += deltaY * 0.3;

      velocityY = deltaX * 0.2;
      velocityX = deltaY * 0.1;

      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    // Touch support
    scene.addEventListener('touchstart', (e) => {
      isDragging = true;
      lastMouseX = e.touches[0].clientX;
      lastMouseY = e.touches[0].clientY;
      velocityX = 0;
      velocityY = 0;
    });

    document.addEventListener('touchmove', (e) => {
      if (!isDragging) return;

      const deltaX = e.touches[0].clientX - lastMouseX;
      const deltaY = e.touches[0].clientY - lastMouseY;

      rotationY += deltaX * 0.5;
      rotationX += deltaY * 0.3;

      velocityY = deltaX * 0.2;
      velocityX = deltaY * 0.1;

      lastMouseX = e.touches[0].clientX;
      lastMouseY = e.touches[0].clientY;
    });

    document.addEventListener('touchend', () => {
      isDragging = false;
    });

    // Start animation
    animate();
  </script>
</body>
</html>
